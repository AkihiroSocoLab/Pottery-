<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>陶芸エディタ — モバイル実行用デモ v0.2</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%F0%9F%8C%8F%3C/text%3E%3C/svg%3E">
<style>
  :root { --bg:#f7f7fb; --fg:#111; --muted:#6b7280; --accent:#111; }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP",sans-serif; }
  .app { display:grid; grid-template-rows:auto 1fr auto; height:100%; }
  header { padding:12px 14px; font-weight:600; border-bottom:1px solid #e5e7eb; background:#fff; }
  #scene { height:56vh; width:100%; background:linear-gradient(#fff,#f3f4f6); } /* ← width:100% 追加 */
  .panel { padding:10px 12px; background:#fff; border-top:1px solid #e5e7eb; }
  .row { display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; margin:8px 0; }
  .row label { font-size:12px; color:var(--muted); }
  .row input[type="range"] { width:70vw; max-width:520px; }
  .pill { display:inline-flex; gap:6px; background:#f3f4f6; border-radius:999px; padding:4px; }
  .pill button { border:0; background:transparent; padding:6px 10px; border-radius:999px; font-size:12px; }
  .pill button.active { background:#111; color:#fff; }
  .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .hint { color:var(--muted); font-size:12px; }
  .btn { width:100%; padding:12px; border-radius:12px; border:0; background:var(--accent); color:#fff; font-weight:600; }
  .stat { font-variant-numeric: tabular-nums; }
  details>summary { cursor:pointer; }
</style>
</head>
<body>
<div class="app">
  <header>陶芸エディタ — モバイルHTMLデモ v0.2（GLB読込＋容量/安定性）</header>
  <div id="scene"></div>
  <div class="panel">
    <div class="row">
      <label>テンプレート / モデル読込（GLB/GLTF）</label>
      <div class="pill" id="tpl">
        <button data-k="cup" class="active">カップ</button>
        <button data-k="vase">花器</button>
        <button data-k="plate">皿</button>
      </div>
    </div>
    <div class="row">
      <label>GLB/GLTFを読み込む</label>
      <input id="glbFile" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json">
    </div>

    <div class="row"><label>高さ h (m)</label><input id="h" type="range" min="0.06" max="0.24" step="0.002" value="0.12"></div>
    <div class="grid2">
      <div class="row"><label>上径 rt (m)</label><input id="rt" type="range" min="0.03" max="0.09" step="0.001" value="0.045"></div>
      <div class="row"><label>底径 rb (m)</label><input id="rb" type="range" min="0.03" max="0.09" step="0.001" value="0.05"></div>
    </div>

    <div class="row"><label>波 振幅 amp (m)</label><input id="amp" type="range" min="0" max="0.004" step="0.0002" value="0"></div>
    <div class="row"><label>波 周波数 freq (周/周方向)</label><input id="freq" type="range" min="0" max="16" step="0.2" value="0"></div>

    <div class="grid2">
      <div class="row"><label>色</label><input id="color" type="color" value="#c9b49e"></div>
      <div class="row"><label>艶 Roughness</label><input id="rough" type="range" min="0" max="1" step="0.02" value="0.6"></div>
    </div>

    <details>
      <summary>画像デカール（任意）</summary>
      <div class="row"><label>画像を選択</label><input id="decalFile" type="file" accept="image/*"></div>
      <div class="grid2">
        <div class="row"><label>位置 X</label><input id="dx" type="range" min="-0.09" max="0.09" step="0.001" value="0"></div>
        <div class="row"><label>位置 Y</label><input id="dy" type="range" min="-0.09" max="0.09" step="0.001" value="0.03"></div>
        <div class="row"><label>位置 Z</label><input id="dz" type="range" min="-0.12" max="0.12" step="0.001" value="0.06"></div>
        <div class="row"><label>Yaw</label><input id="dyaw" type="range" min="-3.1416" max="3.1416" step="0.01" value="0"></div>
        <div class="row"><label>Pitch</label><input id="dpitch" type="range" min="-1.5708" max="1.5708" step="0.01" value="0"></div>
        <div class="row"><label>Roll</label><input id="droll" type="range" min="-3.1416" max="3.1416" step="0.01" value="0"></div>
        <div class="row"><label>幅 W</label><input id="dw" type="range" min="0.01" max="0.15" step="0.001" value="0.06"></div>
        <div class="row"><label>高 H</label><input id="dh" type="range" min="0.01" max="0.15" step="0.001" value="0.06"></div>
        <div class="row"><label>厚み D</label><input id="dd" type="range" min="0.002" max="0.08" step="0.001" value="0.02"></div>
      </div>
      <p class="hint">※ STLにはデカール画像は含まれません（将来のベイク対象）。</p>
    </details>

    <details open>
      <summary>物性チェック（推定値）</summary>
      <div class="grid2">
        <div><span class="hint">容量(内部体積相当)*:</span> <span id="cap" class="stat">-</span> m³</div>
        <div><span class="hint">重量(密度=1800kg/m³):</span> <span id="w" class="stat">-</span> kg</div>
        <div><span class="hint">重心高さ:</span> <span id="cg" class="stat">-</span> m</div>
        <div><span class="hint">底面有効半径:</span> <span id="br" class="stat">-</span> m</div>
        <div><span class="hint">安定性(底半径/重心高):</span> <span id="stab" class="stat">-</span></div>
      </div>
      <p class="hint">* 内部メッシュがないため「外形体積」での簡易推定です。</p>
    </details>

    <div class="row">
      <button id="export" class="btn">STLを書き出す（波形ベイク済）</button>
    </div>
    <p class="hint">ピンチでズーム、ドラッグで回転。重い時は波amp/freqを下げてね。</p>
  </div>
</div>

<!-- ▼ 重要：ESMをCDNのフルURLでimport -->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { STLExporter } from 'https://unpkg.com/three@0.160.0/examples/jsm/exporters/STLExporter.js';
  import { DecalGeometry } from 'https://unpkg.com/three@0.160.0/examples/jsm/geometries/DecalGeometry.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

  const el = (id)=>document.getElementById(id);

  // --- Scene bootstrap ---
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);
  // まれに0pxを拾う環境があるので追い打ちで再setSize
  renderer.setSize(container.clientWidth, container.clientHeight);

  const scene = new THREE.Scene();
  scene.background = null;
  const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.01, 10);
  camera.position.set(0.28, 0.2, 0.28);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.maxDistance = 1.2; controls.minDistance = 0.08;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x777777, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(2,4,2); scene.add(dir);

  const grid = new THREE.GridHelper(1, 10, 0xcccccc, 0xeeeeee); grid.position.y = -0.08; scene.add(grid);

  // --- State ---
  const state = {
    template: 'cup',
    size: { h: parseFloat(el('h').value), rt: parseFloat(el('rt').value), rb: parseFloat(el('rb').value) },
    wave: { amp: parseFloat(el('amp').value), freq: parseFloat(el('freq').value) },
    material: { color: el('color').value, roughness: parseFloat(el('rough').value) },
    decals: [],
    uploadedMesh: null
  };

  // --- Base mesh/material ---
  let baseMesh = null;
  const baseMat = new THREE.MeshStandardMaterial({
    color: state.material.color, roughness: state.material.roughness, metalness: 0.0,
    side: THREE.DoubleSide  // ← 裏面も描画して見失いにくく
  });

  function buildCup({h, rt, rb}){ return new THREE.CylinderGeometry(rt, rb, h, 192, 64, false); }
  function buildVase({h}){
    const pts = []; const H=h; const steps=100;
    const r = t => 0.03 + 0.04 * Math.pow(Math.sin(Math.PI*t), 1.2);
    for(let i=0;i<=steps;i++){ const t=i/steps; pts.push(new THREE.Vector2(r(t), (t-0.5)*H)); }
    return new THREE.LatheGeometry(pts, 192);
  }
  function buildPlate({h, rt}){
    const thickness = Math.max(0.006, h*0.1);
    return new THREE.CylinderGeometry(rt, rt*0.98, thickness, 192, 1, false);
  }

  function applyWave(geom, {amp, freq}){
    if (!amp || !freq) return geom;
    const g = geom.clone();
    const pos = g.attributes.position; const nrm = g.attributes.normal;
    const v = new THREE.Vector3(); const n = new THREE.Vector3();
    for(let i=0;i<pos.count;i++){
      v.fromBufferAttribute(pos, i);
      const ang = Math.atan2(v.z, v.x);
      const disp = amp * Math.sin(ang * freq);
      n.fromBufferAttribute(nrm, i);
      v.addScaledVector(n, disp);
      pos.setXYZ(i, v.x, v.y, v.z);
    }
    pos.needsUpdate = true; g.computeVertexNormals(); g.computeBoundingSphere();
    return g;
  }

  function computeVolumeAndStats(geom){
    let g = geom.index ? geom.toNonIndexed() : geom.clone();
    g.computeBoundingBox(); g.computeVertexNormals();
    const pos = g.attributes.position;
    let vol6 = 0;
    const p0 = new THREE.Vector3(), p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
    for(let i=0; i<pos.count; i+=3){
      p0.fromBufferAttribute(pos, i+0);
      p1.fromBufferAttribute(pos, i+1);
      p2.fromBufferAttribute(pos, i+2);
      vol6 += p0.dot(p1.clone().cross(p2));
    }
    const volume = Math.abs(vol6) / 6.0;
    let ysum = 0;
    for(let i=0; i<pos.count; i++){ ysum += pos.getY(i); }
    const meanY = ysum / pos.count;
    const minY = g.boundingBox.min.y;
    const band = minY + (g.boundingBox.max.y - minY) * 0.03;
    let rmax = 0;
    for(let i=0; i<pos.count; i++){
      const y = pos.getY(i);
      if (y <= band){
        const x = pos.getX(i), z = pos.getZ(i);
        const r = Math.hypot(x, z); if (r > rmax) rmax = r;
      }
    }
    return { volume, meanY, bottomRadius: rmax };
  }

  function updateStats(geometry){
    const { volume, meanY, bottomRadius } = computeVolumeAndStats(geometry);
    const density = 1800;
    el('cap').textContent = volume.toExponential(3);
    el('w').textContent = (volume * density).toFixed(3);
    el('cg').textContent = meanY.toFixed(3);
    el('br').textContent = bottomRadius.toFixed(3);
    const stab = bottomRadius > 0 ? (bottomRadius / Math.max(1e-6, meanY - geometry.boundingBox.min.y)).toFixed(2) : '-';
    el('stab').textContent = String(stab);
  }

  function rebuildBase(){
    if (baseMesh){ scene.remove(baseMesh); baseMesh.geometry.dispose(); }
    let geom;
    if (state.uploadedMesh){
      geom = state.uploadedMesh.clone();
    } else {
      if (state.template==='cup') geom = buildCup(state.size);
      else if (state.template==='vase') geom = buildVase(state.size);
      else geom = buildPlate({h:state.size.h, rt:state.size.rt});
    }
    const deformed = applyWave(geom, state.wave);
    baseMesh = new THREE.Mesh(deformed, baseMat);
    baseMesh.castShadow = baseMesh.receiveShadow = true;
    scene.add(baseMesh);

    state.decals.forEach(d=>{ if (d.mesh){ scene.remove(d.mesh); d.mesh.geometry.dispose(); d.mesh.material.dispose(); d.mesh=null; } });
    state.decals.forEach(d=> applyDecal(d));

    deformed.computeBoundingBox();
    updateStats(deformed);
  }

  function applyDecal(d){
    if (!baseMesh) return;
    const geom = new DecalGeometry(baseMesh, d.position, d.rotation, d.size);
    const mat = new THREE.MeshStandardMaterial({ map: d.map, transparent:true, roughness:0.5, metalness:0, polygonOffset:true, polygonOffsetFactor:-1 });
    const mesh = new THREE.Mesh(geom, mat); mesh.renderOrder = 10;
    d.mesh = mesh; scene.add(mesh);
  }

  document.getElementById('tpl').addEventListener('click', (e)=>{
    if (e.target.tagName!=='BUTTON') return;
    [...e.currentTarget.children].forEach(b=>b.classList.remove('active'));
    e.target.classList.add('active');
    state.template = e.target.dataset.k;
    state.uploadedMesh = null;
    if (state.template==='plate') { el('rt').value = 0.09; state.size.rt=0.09; }
    rebuildBase();
  });

  ['h','rt','rb'].forEach(id=>{
    el(id).addEventListener('input', ()=>{ state.size[id] = parseFloat(el(id).value); if (!state.uploadedMesh) rebuildBase(); });
  });

  ['amp','freq'].forEach(id=>{
    el(id).addEventListener('input', ()=>{ state.wave[id] = parseFloat(el(id).value); rebuildBase(); });
  });

  el('color').addEventListener('input', ()=>{ baseMat.color = new THREE.Color(el('color').value); baseMat.needsUpdate=true; });
  el('rough').addEventListener('input', ()=>{ baseMat.roughness = parseFloat(el('rough').value); baseMat.needsUpdate=true; });

  el('decalFile').addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    const tex = new THREE.TextureLoader().load(url, t=>{ t.needsUpdate=true; });
    const d = {
      map: tex,
      position: new THREE.Vector3(parseFloat(el('dx').value), parseFloat(el('dy').value), parseFloat(el('dz').value)),
      rotation: new THREE.Euler(parseFloat(el('dpitch').value), parseFloat(el('dyaw').value), parseFloat(el('droll').value)),
      size: new THREE.Vector3(parseFloat(el('dw').value), parseFloat(el('dh').value), parseFloat(el('dd').value)),
      mesh: null
    };
    state.decals.push(d); applyDecal(d);
  });

  ['dx','dy','dz','dyaw','dpitch','droll','dw','dh','dd'].forEach(id=>{
    el(id).addEventListener('input', ()=>{
      const d = state.decals[state.decals.length-1]; if(!d) return;
      if (id==='dx'||id==='dy'||id==='dz'){
        d.position[id==='dx'? 'x' : id==='dy'? 'y' : 'z'] = parseFloat(el(id).value);
      } else if (id==='dyaw'||id==='dpitch'||id==='droll'){
        d.rotation[id==='dpitch'? 'x' : id==='dyaw'? 'y' : 'z'] = parseFloat(el(id).value);
      } else {
        d.size[id==='dw'? 'x' : id==='dh'? 'y' : 'z'] = parseFloat(el(id).value);
      }
      if (d.mesh){ scene.remove(d.mesh); d.mesh.geometry.dispose(); d.mesh.material.dispose(); d.mesh=null; }
      applyDecal(d);
    });
  });

  el('glbFile').addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    const loader = new GLTFLoader();
    loader.load(url, (gltf)=>{
      let mesh = null;
      gltf.scene.traverse((o)=>{ if ((o.isMesh || o.type==='Mesh') && !mesh) mesh = o; });
      if (!mesh){ alert('メッシュが見つかりませんでした'); return; }
      mesh.updateWorldMatrix(true, true);
      const geom = mesh.geometry.clone();
      geom.applyMatrix4(mesh.matrixWorld);
      state.uploadedMesh = geom;
      rebuildBase();
    }, undefined, (err)=>{ console.error(err); alert('読み込みに失敗しました'); });
  });

  el('export').addEventListener('click', ()=>{
    if (!baseMesh) return;
    const exporter = new STLExporter();
    const stl = exporter.parse(baseMesh);
    const blob = new Blob([stl], { type: 'application/sla' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `pottery_${Date.now()}.stl`;
    a.click();
  });

  rebuildBase();
  window.addEventListener('resize', ()=>{
    renderer.setSize(container.clientWidth, container.clientHeight);
    camera.aspect = container.clientWidth/container.clientHeight; camera.updateProjectionMatrix();
  });

  renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene, camera); });
</script>
</body>
</html>
